<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="async4j : Callback based asynchronous programing library" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
	<link href="google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
	<script type="text/javascript" src="google-code-prettify/prettify.js"></script>
	 <link href="stylesheets/sunburst.css" type="text/css" rel="stylesheet"/>
    <title>async4j</title>
  </head>

  <body onload="prettyPrint()">

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/amah/async">View on GitHub</a>

          <h1 id="project_title">async4j</h1>
          <h2 id="project_tagline">Callback based asynchronous programing library</h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>Welcome</h3>

<p>Async4j is a library that provides 
callback based control flow for asynchronous 
programing model: pipe, try/catch/finaly, 
condition, foreach and even parallel foreach.
</p>
<h3>Callbacks</h3>
<p>At the heart of async4j library is the Callback interface used to 
capture the completion of asynchronous call, whatever normal or abnormal completion:
<pre class="prettyprint">
public interface Callback<R>{
  public void completed(R result);
  public void error(Throwable t);
}
</pre>
</p>
<p>
The callback interface has nothing very new, it is the well known completion event listener 
widely used in existing asynchronous interaction and generally implements the logic to be run 
on the notification of the task end. The use of callbacks from async4j differ slightly as its
implementations are intended to contain flow control logics such as those provided in this 
the library and not application logics that should be implemented in asynchronous functions 
as described in the following section.

</p>

<h3>Asynchronous function</h3>
From async4j perspective, asynchronous functions has following prototype 
<pre class="prettyprint">
public void operation(Callback<R> k, P1 p1, P2 p2, ...)
</pre>

<p>
It takes at least one callback object as parameter that must be notified exactly one time on 
completion of the asynchronous function :
<ul>
<li><code>k.completed(R r)</code> when the function completed successluly with the asynchronous function output
passed as parameter R to the callback. This function should be call at the tail call position to have asynchronous flows 
work properly.
</li>
<li><code>k.error(Throwable e)</code> to report any exception occured during the asynchronous function execution.</li>
</ul>

The asynchronous function has no return value and must not throw any exception because both should be reported to the callback object.
The callback parameter is passed as first parameter and always named k for pratical reasons:
<ul>
<li>It serves as a clean and distinctive marker of asynchrnous fucntions</li>
<li>Let pet place to pass variable length args when need</li>
</ul>
</p>

<h4>Asynchronous function tempale</h4>
The asynchronous code template guive some guidelines to code asynchronous fucntions
<pre class="prettyprint">
public void operation(Callback<R> k, P p){
  try{
    // Application logic here
    R result = // some result value
    
    k.completed(result)
  } catch(Throwable t){ k.error(t) }
}</pre>
It is not recommanded to catch Throwable but need do so here to match contract for exception management as defined above 


<h3>Synchronous vs Asynchronous call</h3>
Most of asynchronous controls provided by async4j actually make use of callback stack in the same way 
synchronous function call semantics is based on call frame stacks that are transparently managed in the 
assembly or bytecode generated by the compiler. The callback object passed to the asynchronous function 
can be seen as the continuation object the same way the call frame has a return address. When the method 
<code>k.completed(R r)</code> is called at the tail position (what should be the case generally) it play
the same role as <code>return</code> instruction. Similar to the error handling with synchronous call, 
any exception reported through a callback is bubbled up to parent callbacks until it reach a callback
that implements specific handling mecanism like cacth or finally callbacks.
With these similitudes in mind, callbacks notiifcations will be named asynchronous return or asynchronous throw.

<h3>Contols</h3>
<h4>Future callback</h4>
It is the equivalent of the Future based asynchronous call where the result is provided on the calling thread stack. 
The getResult() method blocks until the end of asynchronous operation the futurecallback is passed to, then it return 
a value or throws exception depending on the completion status. The following helper method used to call synchronously
an asynchronous is implemented used the FutureCallback as following  

<pre class="prettyprint">
	public static <P, R> R call(P p, Task<P, R> task) {
		FutureCallback<R> k = new FutureCallback<R>();
		task.run(k, p);
		return k.getResult();
	}
</pre>

This call back is useful when a thread to be kept 
until the asynchronous task end, the main thread if it is the single non daemon thread in the jvm, unit test 
thread or threads bound to transactions for instance. It is the sole callback object that do not have parent.

<h4>Pipe</h4>
The Pipe is a construct that combines two asynchronous operations by calling them sequentially using the pipe callback. 
<pre class="prettyprint">
		String s = Async.call(10, new PipeTask<>(new Task<Integer, Long>() {
			public void run(Callback<? super Long> k, Integer p) {
				k.completed(10 * 2L);
			}
		}, new Task<Long, String>() {
			public void run(Callback<? super String> k, Long p) {
				k.completed(p.toString());
			}
		}));
</pre>

When invoked the pipe construct delegate the call to the first task using a PipeCallback created with initial callback as parent and 
a reference to the second operation. On successful completion of the first operation, the PipeCallback use the output value along with
the parent callback to call the second operation. When the first operation ends with error, the PipeCallback forward the exception to the parent
callback, the second operation is not invoked.

<h4>Nesting asynchronous calls</h4>
Asynchronous operation may call another asynchronous operation in a way that match rules stated above.
<pre class="prettyprint">
public void operation(Callback<R> k, P p){
  try{
    // Do some processing with your parameter p 
    anotherOperation(k, p, ...)
  } catch(Throwable t){ k.error(t) }
}
</pre>
In The callback object is delegated to the anotherOperation() which will take the 
responsability to call methods on the callback object which means the value returned 
asynchronously to the initial caller is one provided by ̀anotherOperation()̀. 
The try/catch is needed to report any exception that occures in the operation proper code.
The call to the nested asynchronous operation is the last instruction (tail call actualy)
to make sur only one error is reported to the callback object. In fact the nested
asynchrnous operation is tail call is a tail call that mey occured before the
call of anotherOperation()

<h4>Asynchronous try / catch / finally</h4>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">async4j maintained by <a href="https://github.com/amah">amah</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
